<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF MASTER PRO - ×’×¨×¡×ª ZIP</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit/dist/fontkit.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        :root {
            --primary: #4f46e5;
            --bg: #f3f4f6;
            --card: #ffffff;
            --text: #1f2937;
            --border: #e5e7eb;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            direction: rtl;
        }

        .container { max-width: 1000px; margin: 0 auto; }
        
        h1 { text-align: center; color: var(--primary); margin-bottom: 30px; }

        /* ×ª×¤×¨×™×˜ ×¢×œ×™×•×Ÿ */
        .nav-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .nav-btn {
            background: white;
            border: 1px solid #ddd;
            padding: 15px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }

        .nav-btn:hover { background: #e0e7ff; border-color: var(--primary); }
        .nav-btn.active { background: var(--primary); color: white; border-color: var(--primary); }

        /* ××–×•×¨ × ×™×”×•×œ ×§×‘×¦×™× */
        .file-manager {
            background: white;
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .file-list {
            list-style: none;
            padding: 0;
            max-height: 250px;
            overflow-y: auto;
        }

        .file-item {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            margin: 5px 0;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 6px;
            cursor: move;
        }
        
        .badge {
            background: #dbeafe;
            color: #1e40af;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        /* ××–×•×¨×™ ×¢×‘×•×“×” */
        .workspace { display: none; background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); }
        .workspace.active { display: block; }

        /* ×›×¤×ª×•×¨×™× ×•×¤×§×“×™× */
        .btn-main {
            background: var(--primary);
            color: white;
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            margin-top: 15px;
        }
        .btn-main:hover { opacity: 0.9; }

        .btn-add {
            background: #10b981;
            color: white;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            display: inline-block;
            margin-bottom: 10px;
        }

        .font-alert {
            background: #fff7ed;
            border: 1px solid #fed7aa;
            color: #9a3412;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        input, select { width: 100%; padding: 10px; margin: 5px 0; border: 1px solid #ccc; border-radius: 6px; box-sizing: border-box; }

        .status-box {
            margin-top: 15px; padding: 15px; border-radius: 8px; text-align: center; display: none;
        }
        .status-box.loading { background: #e0f2fe; color: #075985; }
        .status-box.success { background: #dcfce7; color: #166534; }
        .status-box.error { background: #fee2e2; color: #991b1b; }

    </style>
</head>
<body>

<div class="container">
    <h1>PDF MASTER PRO ğŸš€</h1>

    <div class="nav-grid">
        <div class="nav-btn active" onclick="showTab('merge')">ğŸ”— ××™×—×•×“</div>
        <div class="nav-btn" onclick="showTab('split')">âœ‚ï¸ ×¤×™×¦×•×œ (ZIP)</div>
        <div class="nav-btn" onclick="showTab('convert')">ğŸ–¼ï¸ ×”××¨×” ×œ×ª××•× ×•×ª (ZIP)</div>
        <div class="nav-btn" onclick="showTab('text')">âœï¸ ×˜×§×¡×˜ (×¢×‘×¨×™×ª)</div>
        <div class="nav-btn" onclick="showTab('watermark')">ğŸ’§ ×—×•×ª××ª</div>
        <div class="nav-btn" onclick="showTab('pagenum')">ğŸ”¢ ××¡×¤×•×¨</div>
        <div class="nav-btn" onclick="showTab('img-pdf')">ğŸ“· ×ª××•× ×” ×¢×œ PDF</div>
        <div class="nav-btn" onclick="showTab('bw')">âš« ×©×—×•×¨ ×œ×‘×Ÿ</div>
    </div>

    <div class="file-manager">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h3>ğŸ“‚ ×”×§×‘×¦×™× ×©×œ×š (×’×¨×•×¨ ×œ×©×™× ×•×™ ×¡×“×¨)</h3>
            <label class="btn-add">
                + ×”×•×¡×£ ×§×‘×¦×™×
                <input type="file" multiple accept=".pdf,.jpg,.png,.jpeg" style="display:none" onchange="addFiles(this)">
            </label>
        </div>
        <ul id="file-list" class="file-list">
            <li style="text-align:center; color:#999; padding:20px;">××™×Ÿ ×§×‘×¦×™× ×‘×¨×©×™××”...</li>
        </ul>
        <button onclick="fileQueue=[]; renderFiles();" style="background:#fee2e2; color:red; border:none; padding:5px 10px; border-radius:4px; cursor:pointer;">× ×§×” ×”×›×œ</button>
    </div>

    <div class="font-alert">
        <b>×—×©×•×‘ ×œ×¢×‘×¨×™×ª!</b> ×œ×× ×™×¢×ª ×’'×™×‘×¨×™×©, ×˜×¢×Ÿ ×§×•×‘×¥ ×¤×•× ×˜ (ttf/otf) ××”××—×©×‘ ×©×œ×š:
        <input type="file" accept=".ttf,.otf" onchange="loadFont(this)">
        <span id="font-status" style="margin-right:10px; font-weight:bold;">×œ× × ×˜×¢×Ÿ</span>
    </div>

    <div id="tab-merge" class="workspace active">
        <h2>××™×—×•×“ ×§×‘×¦×™× (PDF ×•×ª××•× ×•×ª)</h2>
        <p>×”×§×‘×¦×™× ×™××•×—×–×• ×œ×¤×™ ×”×¡×“×¨ ×‘×¨×©×™××” ×œ××¢×œ×”.</p>
        <button class="btn-main" onclick="runMerge()">××—×“ ×•×”×•×¨×“ ×§×•×‘×¥ PDF</button>
    </div>

    <div id="tab-split" class="workspace">
        <h2>×¤×™×¦×•×œ PDF (×”×•×¨×“×” ×›-ZIP)</h2>
        <p>××¤×¨×§ ××ª ×”-PDF ×”× ×‘×—×¨ ×œ×¢××•×“×™× × ×¤×¨×“×™× ×•××•×¨×– ××•×ª× ×‘×§×•×‘×¥ ZIP ××—×“ × ×•×—.</p>
        <p style="font-size:0.9em; color:#666;">×¢×•×‘×“ ×¢×œ ×”×§×•×‘×¥ ×”×¨××©×•×Ÿ ×‘×¨×©×™××”.</p>
        <button class="btn-main" onclick="runSplitZip()">×¤×¦×œ ×•×”×•×¨×“ ZIP</button>
    </div>

    <div id="tab-convert" class="workspace">
        <h2>×”××¨×ª PDF ×œ×ª××•× ×•×ª (ZIP)</h2>
        <p>×”×•×¤×š ×›×œ ×¢××•×“ ×‘-PDF ×œ×ª××•× ×” ××™×›×•×ª×™×ª ×•×©×•××¨ ×›-ZIP.</p>
        <label>×¤×•×¨××˜:</label>
        <select id="conv-fmt">
            <option value="jpeg">JPEG (×§×‘×¦×™× ×§×˜× ×™×)</option>
            <option value="png">PNG (××™×›×•×ª ×’×‘×•×”×”)</option>
        </select>
        <button class="btn-main" onclick="runConvertToImagesZip()">×”××¨ ×•×”×•×¨×“ ZIP</button>
    </div>

    <div id="tab-text" class="workspace">
        <h2>×”×•×¡×¤×ª ×˜×§×¡×˜</h2>
        <input type="text" id="txt-val" placeholder="×”×˜×§×¡×˜ ×œ×”×•×¡×¤×”">
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
            <input type="number" id="txt-size" value="24" placeholder="×’×•×“×œ">
            <input type="color" id="txt-color" value="#000000" style="height:45px">
        </div>
        <select id="txt-pos">
            <option value="top-right">×œ××¢×œ×” ××™××™×Ÿ</option>
            <option value="center">××¨×›×–</option>
            <option value="bottom-center">×œ××˜×”</option>
        </select>
        <button class="btn-main" onclick="runAddText()">×”×•×¡×£ ×˜×§×¡×˜</button>
    </div>

    <div id="tab-watermark" class="workspace">
        <h2>×—×•×ª××ª ××™×</h2>
        <input type="text" id="wm-val" placeholder="×˜×§×¡×˜ ×”×—×•×ª××ª">
        <label>×©×§×™×¤×•×ª:</label>
        <input type="range" id="wm-opacity" min="0.1" max="1" step="0.1" value="0.3">
        <button class="btn-main" onclick="runWatermark()">×”×•×¡×£ ×—×•×ª××ª</button>
    </div>

    <div id="tab-pagenum" class="workspace">
        <h2>××¡×¤×•×¨ ×¢××•×“×™×</h2>
        <select id="pg-fmt">
            <option value="num">1, 2, 3</option>
            <option value="eng">Page 1 of 10</option>
            <option value="heb">×¢××•×“ 1 ××ª×•×š 10</option>
        </select>
        <button class="btn-main" onclick="runPageNum()">×”×•×¡×£ ××¡×¤×•×¨</button>
    </div>

    <div id="tab-img-pdf" class="workspace">
        <h2>×ª××•× ×” ×¢×œ PDF</h2>
        <p>×©×™× ×œ×‘: ×”×§×•×‘×¥ ×”×¨××©×•×Ÿ ×‘×¨×©×™××” ×—×™×™×‘ ×œ×”×™×•×ª PDF, ×”×©× ×™ ×ª××•× ×”.</p>
        <label>×’×•×“×œ (Scale):</label>
        <input type="number" id="img-scale" value="0.5" step="0.1">
        <label>×©×§×™×¤×•×ª:</label>
        <input type="range" id="img-op" min="0.1" max="1" step="0.1" value="1">
        <button class="btn-main" onclick="runImgOverlay()">×”×“×‘×§ ×ª××•× ×”</button>
    </div>

    <div id="tab-bw" class="workspace">
        <h2>×”××¨×” ×œ×©×—×•×¨ ×œ×‘×Ÿ</h2>
        <p>×ª×”×œ×™×š ×–×” ×××™×¨ ××ª ×”-PDF ×œ×ª××•× ×•×ª ××¤×•×¨×•×ª ×•×‘×•× ×” ××•×ª×• ××—×“×©.</p>
        <button class="btn-main" onclick="runGrayscale()">×”××¨</button>
    </div>

    <div id="status" class="status-box"></div>
</div>

<script>
    // === ××©×ª× ×™× ===
    let fileQueue = [];
    let customFont = null;
    const { PDFDocument, rgb, degrees, StandardFonts } = PDFLib;

    // === × ×™×”×•×œ UI ===
    function showTab(id) {
        document.querySelectorAll('.workspace').forEach(e => e.classList.remove('active'));
        document.querySelectorAll('.nav-btn').forEach(e => e.classList.remove('active'));
        document.getElementById('tab-' + id).classList.add('active');
        event.currentTarget.classList.add('active');
        setStatus('');
    }

    function setStatus(msg, type = 'loading') {
        const el = document.getElementById('status');
        if (!msg) { el.style.display = 'none'; return; }
        el.innerHTML = msg;
        el.className = 'status-box ' + type;
        el.style.display = 'block';
    }

    // === × ×™×”×•×œ ×§×‘×¦×™× ===
    function addFiles(input) {
        Array.from(input.files).forEach(f => {
            fileQueue.push({
                id: Math.random().toString(36),
                file: f,
                name: f.name,
                type: f.type,
                size: (f.size/1024/1024).toFixed(2) + 'MB'
            });
        });
        renderFiles();
        input.value = '';
    }

    function removeFile(id) {
        fileQueue = fileQueue.filter(f => f.id !== id);
        renderFiles();
    }

    function renderFiles() {
        const list = document.getElementById('file-list');
        list.innerHTML = '';
        if (fileQueue.length === 0) {
            list.innerHTML = '<li style="text-align:center; color:#999; padding:20px;">××™×Ÿ ×§×‘×¦×™×...</li>';
            return;
        }
        fileQueue.forEach((f, i) => {
            const li = document.createElement('li');
            li.className = 'file-item';
            li.setAttribute('data-id', f.id);
            li.innerHTML = `
                <div>
                    <strong>${i+1}. ${f.name}</strong>
                    <span class="badge">${f.type.split('/')[1]}</span>
                </div>
                <button onclick="removeFile('${f.id}')" style="background:none; border:none; cursor:pointer;">âŒ</button>
            `;
            list.appendChild(li);
        });
    }

    // ×”×¤×¢×œ×ª ×’×¨×™×¨×”
    new Sortable(document.getElementById('file-list'), {
        animation: 150,
        onEnd: () => {
            const newOrder = [];
            document.querySelectorAll('.file-item').forEach(el => {
                const id = el.getAttribute('data-id');
                newOrder.push(fileQueue.find(f => f.id === id));
            });
            fileQueue = newOrder;
            renderFiles(); // ×¢×“×›×•×Ÿ ××¡×¤×•×¨
        }
    });

    // === ×¤×•× ×˜ ===
    function loadFont(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            customFont = e.target.result;
            document.getElementById('font-status').innerText = 'âœ… × ×˜×¢×Ÿ: ' + file.name;
            document.getElementById('font-status').style.color = 'green';
        };
        reader.readAsArrayBuffer(file);
    }

    // === ×”×•×¨×“×” ===
    function downloadBlob(blob, name) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = name;
        a.click();
        URL.revokeObjectURL(url);
    }

    // ================== ×¤×•× ×§×¦×™×•×ª ×œ×™×‘×” ==================

    // 1. ××™×—×•×“
    async function runMerge() {
        if (!fileQueue.length) return alert('××™×Ÿ ×§×‘×¦×™×');
        setStatus('×××—×“ ×§×‘×¦×™×...');
        try {
            const doc = await PDFDocument.create();
            for (const item of fileQueue) {
                const bytes = await item.file.arrayBuffer();
                if (item.type === 'application/pdf') {
                    const src = await PDFDocument.load(bytes);
                    const pages = await doc.copyPages(src, src.getPageIndices());
                    pages.forEach(p => doc.addPage(p));
                } else if (item.type.includes('image')) {
                    let img;
                    if (item.type.includes('png')) img = await doc.embedPng(bytes);
                    else img = await doc.embedJpg(bytes);
                    const p = doc.addPage([img.width, img.height]);
                    p.drawImage(img, {x:0, y:0, width:img.width, height:img.height});
                }
            }
            const pdfBytes = await doc.save();
            downloadBlob(new Blob([pdfBytes], {type:'application/pdf'}), 'merged.pdf');
            setStatus('âœ… ××™×—×•×“ ×‘×•×¦×¢!', 'success');
        } catch (e) { setStatus('×©×’×™××”: ' + e.message, 'error'); }
    }

    // 2. ×¤×™×¦×•×œ ×œ-ZIP
    async function runSplitZip() {
        if (!fileQueue.length) return alert('×‘×—×¨ ×§×•×‘×¥ PDF');
        setStatus('××¤×¦×œ ×•××•×¨×– ×œ-ZIP...');
        try {
            const bytes = await fileQueue[0].file.arrayBuffer();
            const srcDoc = await PDFDocument.load(bytes);
            const zip = new JSZip();

            for (let i = 0; i < srcDoc.getPageCount(); i++) {
                const newDoc = await PDFDocument.create();
                const [page] = await newDoc.copyPages(srcDoc, [i]);
                newDoc.addPage(page);
                const pdfBytes = await newDoc.save();
                zip.file(`page_${i+1}.pdf`, pdfBytes);
            }

            const content = await zip.generateAsync({type:"blob"});
            downloadBlob(content, "split_files.zip");
            setStatus('âœ… ×”×•×¨×“×ª ZIP ××•×›× ×”!', 'success');
        } catch (e) { setStatus('×©×’×™××”: ' + e.message, 'error'); }
    }

    // 3. ×”××¨×” ×œ×ª××•× ×•×ª ×œ-ZIP
    async function runConvertToImagesZip() {
        if (!fileQueue.length) return alert('×‘×—×¨ ×§×•×‘×¥ PDF');
        setStatus('×××™×¨ ×¢××•×“×™× ×œ×ª××•× ×•×ª... (×œ×•×§×— ×–××Ÿ)');
        try {
            const bytes = await fileQueue[0].file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(bytes).promise;
            const zip = new JSZip();
            const fmt = document.getElementById('conv-fmt').value;

            for (let i = 1; i <= pdf.numPages; i++) {
                setStatus(`××¢×‘×“ ×¢××•×“ ${i} ××ª×•×š ${pdf.numPages}...`);
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 2 }); // ××™×›×•×ª ×’×‘×•×”×”
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                await page.render({ canvasContext: context, viewport: viewport }).promise;
                const imgData = canvas.toDataURL(`image/${fmt}`, 0.8);
                zip.file(`page_${i}.${fmt}`, imgData.split(',')[1], {base64: true});
            }

            setStatus('××•×¨×– ZIP...');
            const content = await zip.generateAsync({type:"blob"});
            downloadBlob(content, "images.zip");
            setStatus('âœ… ×”××¨×” ×”×•×©×œ××”!', 'success');
        } catch (e) { setStatus('×©×’×™××”: ' + e.message, 'error'); }
    }

    // 4. ×˜×§×¡×˜
    async function runAddText() {
        if (!fileQueue.length) return alert('×‘×—×¨ ×§×•×‘×¥');
        if (!customFont) return alert('×—×•×‘×” ×œ×˜×¢×•×Ÿ ×¤×•× ×˜!');
        setStatus('××•×¡×™×£ ×˜×§×¡×˜...');
        try {
            const doc = await PDFDocument.load(await fileQueue[0].file.arrayBuffer());
            doc.registerFontkit(fontkit);
            const font = await doc.embedFont(customFont);
            const text = document.getElementById('txt-val').value;
            // ×”×™×¤×•×š ×œ×¢×‘×¨×™×ª
            const revText = text.split('').reverse().join('');
            
            const size = parseInt(document.getElementById('txt-size').value);
            const colorHex = document.getElementById('txt-color').value;
            const r = parseInt(colorHex.slice(1,3), 16)/255;
            const g = parseInt(colorHex.slice(3,5), 16)/255;
            const b = parseInt(colorHex.slice(5,7), 16)/255;
            
            doc.getPages().forEach(p => {
                const {width, height} = p.getSize();
                let x=50, y=50;
                const pos = document.getElementById('txt-pos').value;
                if (pos === 'top-right') { x = width - 200; y = height - 50; }
                if (pos === 'center') { x = width/2 - 50; y = height/2; }
                
                p.drawText(revText, { x, y, size, font, color: rgb(r,g,b) });
            });
            downloadBlob(new Blob([await doc.save()], {type:'application/pdf'}), 'text.pdf');
            setStatus('âœ… ×‘×•×¦×¢!', 'success');
        } catch (e) { setStatus('×©×’×™××”: ' + e.message, 'error'); }
    }

    // 5. ×—×•×ª××ª
    async function runWatermark() {
        if (!fileQueue.length) return alert('×‘×—×¨ ×§×•×‘×¥');
        setStatus('××•×¡×™×£ ×—×•×ª××ª...');
        try {
            const doc = await PDFDocument.load(await fileQueue[0].file.arrayBuffer());
            let font;
            if (customFont) {
                doc.registerFontkit(fontkit);
                font = await doc.embedFont(customFont);
            } else {
                font = await doc.embedFont(StandardFonts.Helvetica);
            }
            
            const text = document.getElementById('wm-val').value.split('').reverse().join('');
            const op = parseFloat(document.getElementById('wm-opacity').value);

            doc.getPages().forEach(p => {
                const {width, height} = p.getSize();
                p.drawText(text, {
                    x: width/3, y: height/2,
                    size: 60, font, opacity: op,
                    rotate: degrees(45), color: rgb(0.7,0.7,0.7)
                });
            });
            downloadBlob(new Blob([await doc.save()], {type:'application/pdf'}), 'watermark.pdf');
            setStatus('âœ… ×‘×•×¦×¢!', 'success');
        } catch (e) { setStatus('×©×’×™××”: ' + e.message, 'error'); }
    }

    // 6. ××¡×¤×•×¨
    async function runPageNum() {
        if (!fileQueue.length) return alert('×‘×—×¨ ×§×•×‘×¥');
        setStatus('×××¡×¤×¨...');
        try {
            const doc = await PDFDocument.load(await fileQueue[0].file.arrayBuffer());
            let font;
            if (customFont) {
                doc.registerFontkit(fontkit);
                font = await doc.embedFont(customFont);
            } else {
                font = await doc.embedFont(StandardFonts.Helvetica);
            }
            
            const fmt = document.getElementById('pg-fmt').value;
            const total = doc.getPageCount();

            doc.getPages().forEach((p, i) => {
                const {width} = p.getSize();
                let txt = `${i+1}`;
                if (fmt === 'eng') txt = `Page ${i+1} of ${total}`;
                if (fmt === 'heb') txt = `×¢××•×“ ${i+1} ××ª×•×š ${total}`.split('').reverse().join(''); // ×”×™×¤×•×š ×™×“× ×™
                
                p.drawText(txt, {
                    x: width/2 - 20, y: 20,
                    size: 12, font, color: rgb(0,0,0)
                });
            });
            downloadBlob(new Blob([await doc.save()], {type:'application/pdf'}), 'numbered.pdf');
            setStatus('âœ… ×‘×•×¦×¢!', 'success');
        } catch (e) { setStatus('×©×’×™××”: ' + e.message, 'error'); }
    }

    // 7. ×ª××•× ×” ×¢×œ PDF
    async function runImgOverlay() {
        if (fileQueue.length < 2) return alert('×¦×¨×™×š PDF ×¨××©×•×Ÿ ×•×ª××•× ×” ×©× ×™×™×”');
        setStatus('××“×‘×™×§...');
        try {
            const doc = await PDFDocument.load(await fileQueue[0].file.arrayBuffer());
            const imgBytes = await fileQueue[1].file.arrayBuffer();
            let img;
            if (fileQueue[1].type.includes('png')) img = await doc.embedPng(imgBytes);
            else img = await doc.embedJpg(imgBytes);

            const scale = parseFloat(document.getElementById('img-scale').value);
            const op = parseFloat(document.getElementById('img-op').value);
            const dims = img.scale(scale);

            doc.getPages()[0].drawImage(img, {
                x: 50, y: 50,
                width: dims.width, height: dims.height,
                opacity: op
            });
            downloadBlob(new Blob([await doc.save()], {type:'application/pdf'}), 'overlay.pdf');
            setStatus('âœ… ×‘×•×¦×¢!', 'success');
        } catch (e) { setStatus('×©×’×™××”: ' + e.message, 'error'); }
    }

    // 8. ×©×—×•×¨ ×œ×‘×Ÿ
    async function runGrayscale() {
        if (!fileQueue.length) return alert('×‘×—×¨ ×§×•×‘×¥');
        setStatus('×××™×¨ ×œ×©×—×•×¨ ×œ×‘×Ÿ (×œ×•×§×— ×–××Ÿ)...');
        try {
            const bytes = await fileQueue[0].file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(bytes).promise;
            const newDoc = await PDFDocument.create();

            for (let i = 1; i <= pdf.numPages; i++) {
                setStatus(`××¢×‘×“ ×¢××•×“ ${i}...`);
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 1.5 });
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = viewport.width;
                canvas.height = viewport.height;

                await page.render({ canvasContext: ctx, viewport }).promise;
                
                // ×”×¤×™×›×” ×œ××¤×•×¨
                const imgData = ctx.getImageData(0,0,canvas.width, canvas.height);
                const data = imgData.data;
                for(let j=0; j<data.length; j+=4) {
                    const avg = (data[j] + data[j+1] + data[j+2]) / 3;
                    data[j] = avg; data[j+1] = avg; data[j+2] = avg;
                }
                ctx.putImageData(imgData, 0, 0);

                const imgUrl = canvas.toDataURL('image/jpeg', 0.7);
                const imgB = await fetch(imgUrl).then(r => r.arrayBuffer());
                const emb = await newDoc.embedJpg(imgB);
                const p = newDoc.addPage([emb.width, emb.height]);
                p.drawImage(emb, {x:0, y:0, width:emb.width, height:emb.height});
            }
            downloadBlob(new Blob([await newDoc.save()], {type:'application/pdf'}), 'bw.pdf');
            setStatus('âœ… ×‘×•×¦×¢!', 'success');
        } catch (e) { setStatus('×©×’×™××”: ' + e.message, 'error'); }
    }

</script>
</body>
</html>
